c++编码规范 v1.0
====
```
author:Allen.l  email:lp112124@163.com
```  
note: 基本与google一致,有些许修改.  
<http://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/>
  
  
##1. 头文件  
###1.1 #include 的路径及顺序  
-  关联头文件  
-  C 系统文件  
-  C++ 系统文件  
-  其他库的 .h 文件  
-  本项目内 .h 文件  
-  各类别文件之间空行
-  项目内头文件应按照项目源代码目录树结构排列 eg 1.#include "base/logging.h"
###1.2 #define 保护  
- 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径  
- foo/src/bar/baz.h
- #ifndef FOO_BAR_BAZ_H_
- #define FOO_BAR_BAZ_H_
- #endif // FOO_BAR_BAZ_H_
###1 总结
- 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应
- 内联函数的合理使用可提高代码执行效率
- 标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起)
- 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯
- 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 .cc 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则
- 注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员
##2. 作用域
###2.1 命名空间  
- 鼓励在 .cc 文件内使用匿名命名空间.
- 使用具名的命名空间时, 其名称可基于项目名或相对路径.   
- 禁止使用 using 指示（*using-directive*）.
- 禁止使用内联命名空间（*inline namespace*）.
- 不要在 .h 文件中使用匿名命名空间.
- 不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体会导致不确定的问题, 比如不可移植. 声明标准库下的实体, 需要包含对应的头文件.
- 最好不要使用 using 指示，以保证命名空间下的所有名称都可以正常使用.
- 在 .cc 文件, .h 文件的函数, 方法或类中, 可以使用 using 声明和命名空间别名.
###2.2 非成员函数、静态成员函数和全局函数
- 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数.
- 如果你必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用匿名 namespaces`或 ``static` 链接关键字 (如 static int Foo() {...}) 限定其作用域.
- 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
- 禁止使用 class 类型的静态或全局变量：它们会导致难以发现的 bug 和不确定的构造和析构函数调用顺序。不过 constexpr 变量除外，毕竟它们又不涉及动态初始化或析构.
###2 总结
- cc 中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用 using 关键字污染命名空间.
- 嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 public.
- 尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元.
- 多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug.
- 作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.
##3. 类
###3.1 构造函数的职责
- 不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.
- 构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 Init() 方法或工厂函数.
- 构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式.
###3.2 隐式类型转换
- 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字.
- 在类型定义中, 类型转换运算符和单参数构造函数都应当用 explicit 进行标记.
- 拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换.
- 对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的.
- 不能以一个参数进行调用的构造函数不应当加上 explicit. 接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化.
###3.3 可拷贝类型和可移动类型
- 如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.
- 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝.如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然.
- 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.
- 如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.
- 由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现.
- 如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之.
###3.4 结构体 VS. 类
- 仅当只有数据成员时使用 struct, 其它一概使用 class.
- struct 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.
- 如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class.
- 为了和 STL 保持一致, 对于仿函数等特性可以不用 class 而是使用 struct.
###3.5 继承
- 使用组合 (YuleFox 注: 这一点也是 GoF 在 <<Design Patterns>> 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.
- 所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.
- 不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo.
- 必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数.
- 对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 注意, 数据成员都必须是 私有的.
- 对于重载的虚函数或虚析构函数,在声明重载时, 请使用 override, final 或 virtual 的其中之一进行标记. 
###3.5 多重继承
- 真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.
- 只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀.
###3.6 接口
- 接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制).
- 只有在满足上述条件时, 类才以 Interface 结尾, 但反过来, 满足上述需要的类未必一定以 Interface 结尾.
###3 总结
- 不在构造函数中做太多逻辑相关的初始化;
- 编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;
- 为避免隐式转换, 需将单参数构造函数声明为 explicit;
- 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现;
- 仅在作为数据集合时使用 struct;
- 组合 > 实现继承 > 接口继承 > 私有继承, 子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这样做;
- 避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;
- 接口类类名以 Interface 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 protected;
- 为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;
- 存取函数一般内联在头文件中;
- 声明次序: public -> protected -> private;
- 函数体尽量短小, 紧凑, 功能单一;
##4. 函数
###4.1 函数重载
- 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.
- 如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气重载多个 Append(). 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.
###4.2 缺审函数
- 只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.
- 对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 void f(int n = counter++); 这样的代码.)
- 在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.
###4.3 函数返回类型后置语法
- 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.
- 在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 复杂的模板代码.
###4 总结
- 函数的参数顺序为: 输入参数在先, 后跟输出参数.
- C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或 const 引用, 输出参数或输入/输出参数则一般为非 const 指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 
- 所有按引用传递的参数必须加上 const.
- 函数参数列表中, 所有引用参数都必须是 const.
- 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap().
- 有时候, 在输入形参中用 const T* 指针比 const T& 更明智. 比如:1.可能会传递空指针 2.函数要把指针或对地址的引用赋值给输入形参.
- 大多时候输入形参往往是 const T&. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑.
##5. 来自 Google 的奇技
###5.1 所有权与智能指针
- 动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.
- std::unique_ptr 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 std::unique_ptr 离开作用域时, 对象就会被销毁. std::unique_ptr 不能被复制, 但可以把它移动（move）给新所有主. std::shared_ptr 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.
- 如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.
- 传递对象的所有权, 开销比复制来得小, 如果可以复制的话.
- 传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.
- 如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.
- 可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.
- 对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.
- 如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 std::unique_ptr 来明确所有权传递.
- 如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 std::shared_ptr<const Foo> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 std::shared_ptr .
###5.2 Cpplint
- cpplint.py 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错.
###5 总结
- 把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了.
- 原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.
- scoped_ptr 和 auto_ptr 已过时. 现在是 shared_ptr 和 uniqued_ptr 的天下了.
- 按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.
##6. 命名约定
###6.1 通用命名规则
- 函数命名, 变量命名, 文件命名要有描述性; 少用缩写. eg 1.int price_count_reader; 2.int num_errors;
- 一些特定的广为人知的缩写是允许的, 例如用 i 表示迭代变量和用 T 表示模板参数.
- 模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循 类型命名 的规则, 而非类型模板应当遵循 变量命名 的规则.
###6.2 文件命名
- 文件名要全部小写, 可以包含下划线 (_).（eg 1.my_useful_class.cc 2.myusefulclass.cc）
- C++ 文件要以 .cc 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾, 参见 头文件自足.
- 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar.
- 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中.
###6.3 类型命名
- 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
- 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. eg 1.class UrlTable 2.struct UrlTableProperties 3.typedef hash_map<UrlTableProperties *, string> PropertiesMap 4.using PropertiesMap = hash_map<UrlTableProperties *, string> 5. enum UrlTableErrors 
###6.4 变量命名
- 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用。
- 普通变量 eg 1.string table_name; 2.string tablename;
- 类数据成员 eg 1.string_ table_name_; 2.string tablename_; 3.static Pool<TableInfo>* static_pool_;
- 结构体变量 不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线.
- 常量命名 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. eg 1.const int kDaysInAWeek = 7;
- 函数命名 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配. eg 1.MyExcitingFunction(), 2.MyExcitingMethod(), 3.my_exciting_member_variable(), 4.set_my_exciting_member_variable().
- 命名空间命名 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.
- 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME. 单独的枚举值应该优先采用 常量 的命名方式.
- 宏命名 eg 1.MY_MACRO_THAT_SCARES_SMALL_CHILDREN
##7. 注释
- 参考顶级链接google代码注释
##8. 格式
- 参考顶级链接google代码格式







